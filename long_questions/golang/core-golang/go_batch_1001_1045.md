## ðŸ†• Modern Go Features (v1.22â€“v1.24) (Questions 1001-1020)

### Question 1001: What is the loop variable scope change in Go 1.22?

**Answer:**
Before Go 1.22, loop variables were shared across iterations, causing bugs in closures (capturing the last value).
In Go 1.22, the loop variable is **per-iteration**.
```go
// Go 1.22+
for i := 0; i < 3; i++ {
    go func() {
        fmt.Println(i) // Now prints 0, 1, 2 correctly (order undefined of course)
    }()
}
```

---

### Question 1002: How do you iterate over integers in Go 1.22 (`for i := range n`)?

**Answer:**
Go 1.22 allows range over integers:
```go
for i := range 5 {
    fmt.Println(i) // Prints 0, 1, 2, 3, 4
}
```
This simplifies standard counting loops.

---

### Question 1003: How does `net/http.ServeMux` support wildcards and methods in Go 1.22?

**Answer:**
The standard library router now supports methods and path parameters:
```go
mux := http.NewServeMux()
mux.HandleFunc("GET /items/{id}", handleGetItem)
mux.HandleFunc("POST /items", handleCreateItem)
```
You can retrieve values using `r.PathValue("id")`.

---

### Question 1004: What is the new `math/rand/v2` package?

**Answer:**
`math/rand/v2` is a standard library revision in Go 1.22+:
- Faster, more cryptographically secure algorithms (ChaCha8, PCG).
- No global shared state (no global lock on `Intn`).
- `rand.N(n)` replaces `rand.Intn(n)` for generic types.

---

### Question 1005: What are Go Iterators (`range-over-func`) in Go 1.23?

**Answer:**
Go 1.23 introduces standard iterators. You can range over a function that matches specific signatures (`func(func() bool)` or `func(func(V) bool)`).
```go
func CountTo(n int) iter.Seq[int] {
    return func(yield func(int) bool) {
        for i := 0; i < n; i++ {
            if !yield(i) { return }
        }
    }
}
// Usage: for x := range CountTo(5) { ... }
```

---

### Question 1006: How do you use the `unique` package in Go 1.23?

**Answer:**
`unique` package provides canonicalization (interning) of values.
```go
h1 := unique.Make("hello")
h2 := unique.Make("hello")
// h1 == h2 is a very fast pointer comparison.
```
Useful for reducing memory usage when many duplicate strings/values exist.

---

### Question 1007: What improvements were made to `time.Timer` garbage collection in Go 1.23?

**Answer:**
Timers and Tickers that are no longer referenced are now immediately eligible for garbage collection, even if they haven't fired yet. `Stop()` is no longer strictly required for GC (though still good practice).

---

### Question 1008: What are generic type aliases in Go 1.24?

**Answer:**
You can now alias generic types:
```go
type MyMap[K comparable, V any] = map[K]V
type StringIntMap = MyMap[string, int]
```

---

### Question 1009: How do you use the `go tool` directive in `go.mod` (Go 1.24)?

**Answer:**
You can track executable tool dependencies in `go.mod`:
```
tool golang.org/x/tools/cmd/stringer
```
Run with `go tool stringer`. This removes the need for `tools.go` hacks.

---

### Question 1010: What is `os.Root` and how does it improve file system isolation (Go 1.24)?

**Answer:**
`os.OpenRoot("path")` returns a `Root` object. All operations on that object are confined to that directory tree, preventing path traversal attacks (like `../`).

---

### Question 1011: How do you implement weak pointers in Go 1.24?

**Answer:**
Using the `weak` package. A weak pointer references an object without preventing it from being garbage collected.
```go
ref := weak.Make(&obj)
if p := ref.Pointer(); p != nil {
    // object still exists
}
```

---

### Question 1012: What is the `omitzero` struct tag option?

**Answer:**
In `encoding/json` (Go 1.24), `omitzero` omits the field if it has the zero value for its type, handling structs correctly (unlike `omitempty` which had issues with zero-values vs nil).

---

### Question 1013: How do you use `testing.B.Loop` for benchmarks?

**Answer:**
`b.Loop()` simplifies benchmarks by handling the loop internally:
```go
func BenchmarkFoo(b *testing.B) {
    for b.Loop() {
        Foo()
    }
}
```

---

### Question 1014: How does Go 1.24 support FIPS 140-3 compliance?

**Answer:**
Go 1.24 adds a `GOFIPS=1` mode that enforces using FIPS-certified cryptographic primitives in the `crypto` standard library, essential for government compliance.

---

### Question 1015: What are usage comparisons for `slices.Concat`?

**Answer:**
`slices.Concat(s1, s2, s3)` is optimized and cleaner than multiple `append` calls. It pre-calculates the total capacity needed.

---

### Question 1016: How do you use `runtime.AddCleanup` vs `SetFinalizer`?

**Answer:**
`AddCleanup` is the modern, safer alternative to `SetFinalizer`. It attaches a cleanup function to an object that runs after the object is unreachable. It allows multiple cleanups and doesn't resurrect objects.

---

### Question 1017: What are the new WASM export capabilities in Go?

**Answer:**
Go can now export functions to the WASM host using `//go:wasmexport`. This allows calling Go functions directly from JavaScript/Host without the `syscall/js` overhead.

---

### Question 1018: How do you debug using `go build -asan`?

**Answer:**
`-asan` enables the **Address Sanitizer**. It detects C/C++ style memory corruption errors (buffer overflows, use-after-free) in Go code that uses cgo or `unsafe`.

---

### Question 1019: How do you manage tool dependencies without a `tools.go` file now?

**Answer:**
Use the `tool` directive in `go.mod` (Go 1.24 feature) to explicitly list independent executable dependencies.

---

### Question 1020: What is the anticipated "Flight Recorder" feature?

**Answer:**
A structured logging system that keeps a ring buffer of recent logs/events in memory. If a crash occurs, this buffer can be dumped for debugging, minimizing I/O overhead during normal operation.

---

## ðŸ§© Niche Patterns, Frameworks & Tricky Snippets (Questions 1021-1045)

### Question 1021: How do you implement the "Or-Done" channel pattern in Go?

**Answer:**
Wraps a channel read with a context/done channel check to avoid blocking forever.
```go
func orDone(done <-chan struct{}, c <-chan int) <-chan int {
    valStream := make(chan int)
    go func() {
        defer close(valStream)
        for {
            select {
            case <-done:
                return
            case v, ok := <-c:
                if !ok { return }
                select {
                case valStream <- v:
                case <-done:
                }
            }
        }
    }()
    return valStream
}
```

---

### Question 1022: What is a "Tee-Channel" and how do you implement it?

**Answer:**
Splits one input channel into two identical output channels (like the Unix `tee` command).
```go
func tee(in <-chan int) (<-chan int, <-chan int) {
    out1 := make(chan int)
    out2 := make(chan int)
    go func() {
        defer close(out1); defer close(out2)
        for val := range in {
            out1 <- val
            out2 <- val
        }
    }()
    return out1, out2
}
```

---

### Question 1023: How do you implement a "Bridge-Channel" to consume a sequence of channels?

**Answer:**
Consumes a stream of channels (`<-chan <-chan T`) and merges them into a single output channel.
```go
func bridge(inputs <-chan <-chan int) <-chan int {
    out := make(chan int)
    go func() {
        defer close(out)
        for stream := range inputs {
            for val := range stream {
                out <- val
            }
        }
    }()
    return out
}
```

---

### Question 1024: What is the **Temporal.io** workflow engine and how does it use Go?

**Answer:**
Temporal provides durable execution. Its core engine and Go SDK allow writing code that runs reliably despite failures. It uses Go's concurrency primitives to model long-running business logic (workflows) as code.

---

### Question 1025: How does **Temporal** ensure determinism in Go workflows?

**Answer:**
Workflow code must be deterministic (same input = exact same execution path).
- No native goroutines (use `workflow.Go`).
- No `time.Now()` (use `workflow.Now`).
- No iterating over maps without sorting (random order).
- Determinism allows Temporal to replay history to restore state.

---

### Question 1026: What is the **Ent** framework and how does it differ from GORM?

**Answer:**
Ent is an entity framework for Go (created by Meta).
- **Schema-as-Code**: Schemas are defined in Go code, not structs.
- **Code Generation**: Generates type-safe, fluent API client.
- **Graph-Oriented**: Handles complex traversals better than typical ORMs.
- GORM is runtime reflection-based; Ent is compile-time generation-based.

---

### Question 1027: How do you define graph-based schemas (Edges) in **Ent**?

**Answer:**
```go
func (User) Edges() []ent.Edge {
    return []ent.Edge{
        edge.To("pets", Pet.Type),
        edge.From("groups", Group.Type).Ref("users"),
    }
}
```
Defines relationships explicitly in schema files.

---

### Question 1028: **Tricky Snippet**: What is the output of `fmt.Println(s)` if `s := []int{1,2,3}; append(s[:1], 4)` is called?

**Answer:**
It prints `[1 4 3]`.
`s[:1]` is a slice of length 1, capacity 3. `append` writes 4 to index 1. Since `s` still points to the same underlying array, the original slice sees the modification.
*Wait, `append` returns a new slice.* `s` itself is NOT updated by the `append` return value, but the *underlying array* might be modified.
Correct Check: `s` (original) is `[1, 2, 3]`. `append` writes `4` at index 1. The array becomes `[1, 4, 3]`. So `s` sees `[1, 4, 3]`.

---

### Question 1029: **Tricky Snippet**: Why is `interface{}(*int(nil)) != nil` true?

**Answer:**
An interface is a tuple `(type, value)`.
`*int(nil)` has type `*int` and value `nil`.
The interface holds `(*int, nil)`.
A nil interface is `(nil, nil)`.
Therefore, they are not equal. This is a common trap (The "typed nil" problem).

---

### Question 1030: **Tricky Snippet**: What happens if you run `for k, v := range m` on the same map multiple times?

**Answer:**
The iteration order is randomized by the Go runtime (specifically to prevent reliance on order). You will likely get different orders each time.

---

### Question 1031: **Tricky Snippet**: What happens when you close a nil channel?

**Answer:**
It causes a **panic** (`panic: close of nil channel`).

---

### Question 1032: **Tricky Snippet**: Can you take the address of a map value (`&m["key"]`)? Why or why not?

**Answer:**
**No.** Go forbids this (`cannot take the address of m["key"]`).
Map values are not addressable because the map implementation might move the value in memory during growth/rebalancing.

---

### Question 1033: How do you use `golang.org/x/sync/errgroup` for error propagation?

**Answer:**
`errgroup` synchronizes a group of goroutines and returns the first non-nil error.
```go
g, ctx := errgroup.WithContext(context.Background())
g.Go(func() error { return fetchURL(ctx, url1) })
g.Go(func() error { return fetchURL(ctx, url2) })
if err := g.Wait(); err != nil {
    // Handle first error
}
```

---

### Question 1034: What is the "Function Options" pattern for constructor configuration?

**Answer:**
Use variadic functions passing closures to configure an object.
```go
func NewServer(opts ...Option) *Server {
    s := &Server{}
    for _, opt := range opts { opt(s) }
    return s
}
func WithPort(p int) Option {
    return func(s *Server) { s.Port = p }
}
```

---

### Question 1035: How do you use `singleflight` to prevent cache stampedes?

**Answer:**
`singleflight.Group` suppresses duplicate function calls.
```go
var g singleflight.Group
val, err, shared := g.Do("key", func() (interface{}, error) {
    return expensiveDBQuery()
})
```
If 100 requests come in for "key", only 1 DB query runs; all 100 receive the result.

---

### Question 1036: What is `uber-go/automaxprocs` and why is it used in K8s?

**Answer:**
In K8s/Docker, `runtime.NumCPU()` sees the Host CPU count, not the Container Quota (Limit). This causes Go to spawn too many threads, causing throttling.
`automaxprocs` automatically sets `GOMAXPROCS` to match the container's CPU quota.

---

### Question 1037: How do you implement "Circuit Breaker" using `sony/gobreaker` or similar?

**Answer:**
Wraps a function execution. If failure rate exceeds threshold, the breaker "trips" (Open state) and fails fast for a timeout duration, giving the downstream service time to recover.

---

### Question 1038: How do you use build tags to separate integration tests (`//go:build integration`)?

**Answer:**
Add `//go:build integration` to top of test files.
Run standard unit tests: `go test ./...` (skips integration).
Run integration tests: `go test -tags=integration ./...`.

---

### Question 1039: What is the difference between `crypto/rand` and `math/rand/v2` in terms of security?

**Answer:**
- `crypto/rand`: Reads from OS entropy (random device). Cryptographically secure. Slow. Use for keys/passwords.
- `math/rand`: Pseudo-random number generator (PRNG). Fast. Deterministic if seeded. Use for simulations/games. `v2` is better but still PRNG.

---

### Question 1040: How do you use `go-cmp` for comparing complex structs in tests?

**Answer:**
`reflect.DeepEqual` is strict and fragile. `google/go-cmp/cmp` allows options:
```go
if diff := cmp.Diff(want, got, cmpopts.IgnoreFields(User{}, "CreatedAt")); diff != "" {
    t.Errorf("Mismatch (-want +got):\n%s", diff)
}
```

---

### Question 1041: What is "Mutation Testing" and are there tools for it in Go?

**Answer:**
Mutation testing modifies code (mutants) to see if tests fail. If tests pass despite mutation, the test is weak.
Tool: `gremlins` or `go-mutesting` (though less mature than Java's PIT).

---

### Question 1042: How do you handle "Dual-Writes" (DB + Message Queue) consistency?

**Answer:**
The "Transactional Outbox" pattern.
1. Start DB Transaction.
2. Write Data to Table.
3. Write Event to `Outbox` Table.
4. Commit Transaction.
5. Separate process (poll/CDC) reads Outbox and publishes to Kafka.

---

### Question 1043: What is the "Outbox Pattern" and how to implement it in Go?

**Answer:**
(See Q1042). It ensures atomicity of "State Change" and "Event Publishing" by using the database transaction for both.

---

### Question 1044: How does Go's "semver" compatibility guarantee work for standard library?

**Answer:**
Go 1 guarantees backward compatibility. A program written in Go 1.0 (2012) should compile and run on Go 1.24 (2025) without changes, with very few documented exceptions.

---

### Question 1045: How do you use `gdb` or `delve` to debug a running process (attach)?

**Answer:**
**Delve (dlv)** is preferred for Go.
```bash
dlv attach <PID>
```
Once attached:
- `grs` (goroutines)
- `bt` (backtrace)
- `print variable`
- `continue`
```
