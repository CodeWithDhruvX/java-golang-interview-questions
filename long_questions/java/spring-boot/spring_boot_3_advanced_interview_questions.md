# Spring Boot 3 & Advanced Interview Questions

## Spring Boot 3.0 Features

### 1. What are the major changes in Spring Boot 3.0?
Spring Boot 3.0 (released Nov 2022) is a major overhaul:
-   **Java 17 Baseline:** It requires JDK 17 or higher.
-   **Jakarta EE 9/10:** Migration from `javax.*` to `jakarta.*` packages (e.g., `jakarta.servlet`, `jakarta.persistence`).
-   **Native Image Support:** First-class support for GraalVM Native Images.
-   **Observability:** Introduction of Micrometer Tracing (replacing Spring Cloud Sleuth).

### 2. Why did Spring Boot migrate from `javax` to `jakarta`?
This is due to the transfer of Java EE from Oracle to the Eclipse Foundation. The `javax` namespace could not be used by Eclipse, necessitating the rename to `jakarta`. This is a breaking change for older libraries.

### 3. What is AOT (Ahead-of-Time) compilation in Spring Boot?
AOT processing inspects the application at build time to generate optimized code, distinct from the traditional JIT (Just-In-Time) compilation.
-   It identifies beans and configuration.
-   It generates code to register beans, avoiding reflection at runtime.
-   It is the foundation for GraalVM Native Images.

## Native Images & GraalVM

### 4. What is a Native Image?
A **Native Image** is a standalone executable (binary) generated by compiling Java bytecode ahead-of-time (AOT).
-   **Advantages:** Instant startup (milliseconds), very low memory footprint, smaller container images.
-   **Disadvantages:** Longer build times, no runtime optimizations (JIT), limited reflection/dynamic proxy support (requires configuration).

### 5. How do you build a Native Image with Spring Boot?
You use the GraalVM Native Build Tools.
-   **Maven:** `./mvnw -Pnative spring-boot:build-image` (Buildpacks) or `native:compile`.
-   **Gradle:** `./gradlew bootBuildImage`.

### 6. What are the limitations of Native Images?
-   **Reflection:** Requires explicit configuration (hints) for classes loaded via reflection.
-   **Resources:** Classpath resources must be explicitly registered.
-   **Proxies:** Dynamic proxies (CGLIB) need hints.
-   Spring Boot 3 auto-configures most hints for you, but 3rd party libraries might break.

## Observability & Monitoring

### 7. What happened to Spring Cloud Sleuth in Boot 3?
Spring Cloud Sleuth has been **removed/superseded** by **Micrometer Tracing**.
-   Micrometer (metrics) + Micrometer Tracing (logs/traces) provides a unified observability facade.
-   It supports OpenTelemetry and OpenZipkin standards.

### 8. How do you implement Distributed Tracing in Spring Boot 3?
1.  Add `micrometer-tracing-bridge-otel` (OpenTelemetry) or `micrometer-tracing-bridge-brave`.
2.  Add a reporter (e.g., `zipkin-reporter-brave`).
3.  Spring automatically injects `traceId` and `spanId` into logs (MDC).

## Advanced Internals

### 9. What is an `EnvironmentPostProcessor`?
It is an interface that allows you to customize the application's `Environment` *before* the application context is refreshed.
-   **Use Case:** Loading custom properties from a remote server/database, decrypting secrets before startup.
-   Registered in `META-INF/spring.factories` (or `org.springframework.boot.env.EnvironmentPostProcessor.imports`).

### 10. What is a `FailureAnalyzer`?
It is used to intercept exceptions that occur during startup and transform them into a human-readable failure analysis (the "banner" style error messages you see in console).
-   **Example:** "Port 8080 is already in use."

### 11. What is the difference between `@Configuration(proxyBeanMethods = false)` and `true`?
-   **`true` (Full Mode):** Default. Configuration class is proxied (CGLIB). Calling a `@Bean` method calls the container's lifecycle (ensures singleton). Slower startup.
-   **`false` (Lite Mode):** The class is not proxied. Calling a `@Bean` method acts like a normal Java method call (creates a *new* instance). Faster startup. Use this if you don't have inter-bean dependencies.

### 12. How do Buildpacks work in Spring Boot?
Spring Boot includes support for Cloud Native Buildpacks (CNB).
-   Command: `mvn spring-boot:build-image`
-   It analyzes your app, wraps it in a container image with a JVM, and layers the JAR (dependencies vs application code) for efficient Docker caching, without needing a `Dockerfile`.
