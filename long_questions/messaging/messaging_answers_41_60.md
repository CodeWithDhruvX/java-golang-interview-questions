## ðŸŸ¢ ActiveMQ (Questions 41-60)

### Question 41: What is ActiveMQ?

**Answer:**
Apache ActiveMQ is a popular open-source, multi-protocol, Java-based message broker.
*   **Standards:** It implements the JMS (Java Message Service) 1.1 specification and supports a wide range of cross-language clients and protocols.
*   **Flexibility:** It can be used as a standalone service or embedded strictly within a Java application.

### Question 42: What are the key features of ActiveMQ?

**Answer:**
1.  **Multi-Protocol Support:** Supports OpenWire, STOMP, AMQP, MQTT, and REST.
2.  **JMS Compliance:** Fully compliant with JMS 1.1 standards (Classic).
3.  **Clustering & Failover:** Supports Master-Slave and Network of Brokers configurations.
4.  **Persistence:** Configurable storage backends (KahaDB, JDBC, LevelDB).
5.  **Integration:** Works seamlessly with Spring, Camel, and application servers like TomEE.

### Question 43: What is the difference between Queue and Topic in ActiveMQ (JMS)?

**Answer:**
*   **Queue (Point-to-Point):**
    *   One producer sends a message to a queue.
    *   **Only one** consumer receives that specific message.
    *   If no consumer is listening, the message stays in the queue.
*   **Topic (Publish-Subscribe):**
    *   One producer publishes a message to a topic.
    *   **All** active subscribers receive a copy of the message.
    *   If no subscribers are listening, the message is discarded (unless it's a Durable Subscription).

### Question 44: What protocols does ActiveMQ support?

**Answer:**
*   **OpenWire:** The native/default high-performance protocol for ActiveMQ (Java, C++, C#, Python).
*   **AMQP:** Advanced Message Queuing Protocol (Standard for interoperability).
*   **STOMP:** Simple Text Oriented Messaging Protocol (Great for scripting languages like Ruby, Python).
*   **MQTT:** Lightweight protocol typically used for IoT (Internet of Things).
*   **WS/WSS:** WebSockets for browser-based messaging.

### Question 45: How does ActiveMQ handle persistence?

**Answer:**
ActiveMQ uses a "Message Store" to persist messages to the disk so they are not lost if the broker crashes.
*   **Mechanics:** When a persistent message is received, it is written to the store before an acknowledgment is sent to the producer.
*   **Types:**
    *   **KahaDB:** (Default) File-based, highly optimized.
    *   **JDBC:** Stores messages in a relational database (SQL, Oracle). Slower but easier to manage.

### Question 46: What is KahaDB in ActiveMQ?

**Answer:**
KahaDB is the default persistence adapter for ActiveMQ Classic (since v5.4).
*   **Structure:** It uses a transactional journal (append-only log) for speed and a B-Tree index for quick retrieval of message locations.
*   **Performance:** It is much faster than the JDBC store because it avoids the overhead of SQL parsing and transaction management of an RDBMS.

### Question 47: What is the difference between persistent and non-persistent delivery?

**Answer:**
This is a property set on the Message Producer.
*   **Persistent (`DeliveryMode.PERSISTENT`):** Messages are logged to disk/database. They survive a broker restart. This is the default.
*   **Non-Persistent (`DeliveryMode.NON_PERSISTENT`):** Messages are kept in memory only. Faster, but if the broker crashes, messages are lost.

### Question 48: What is a Dead Letter Queue (DLQ) in ActiveMQ?

**Answer:**
A DLQ is a standard queue (named `ActiveMQ.DLQ` by default) where ActiveMQ moves messages that usually cannot be delivered.
*   **Triggers:**
    *   Message expires (Time-to-Live exceeded).
    *   Maximum Redelivery attempts reached (consumer keeps failing/rolling back).
*   **Handling:** Admins can inspect the DLQ to diagnose why messages are failing.

### Question 49: How does ActiveMQ support clustering/failover?

**Answer:**
*   **Client-Side Failover:** The connection string allows the client to auto-connect to a backup.
    *   `failover:(tcp://master:61616,tcp://slave:61616)`
*   **Master-Slave:** Two brokers share a file system (Shared File System Master Slave) or database (JDBC Master Slave). Only one is active (Master); the other waits for the lock. If Master dies, Slave takes over.

### Question 50: What is the Network of Brokers in ActiveMQ?

**Answer:**
A Network of Brokers creates a mesh of ActiveMQ instances where messages are forwarded from one broker to another based on consumer demand.
*   **Scenario:** Producer is on Broker A, Consumer is on Broker B. Broker A forwards the message to Broker B.
*   **Benefit:** Distributed load, improved scalability, and connectivity across WANs.

### Question 51: What is Advisory Message in ActiveMQ?

**Answer:**
Advisory messages are internal system messages generated by the broker on special topics (prefix `ActiveMQ.Advisory.`).
*   **Usage:** They inform you about events occurring in the broker.
*   **Examples:** A new consumer started (`Consumer.Start`), a connection was opened/closed, or a queue is full.

### Question 52: How do you secure ActiveMQ?

**Answer:**
1.  **Transport Security:** Use SSL/TLS (`ssl://0.0.0.0:61617`) to encrypt data on the wire.
2.  **Authentication:** Use JAAS (Java Authentication and Authorization Service) plugins (SimpleAuthenticationPlugin, LDAP, PropertiesFile).
3.  **Authorization:** Define access lists (ACLs) to control who can read/write to specific queues/topics.

### Question 53: What is the difference between ActiveMQ Classic and ActiveMQ Artemis?

**Answer:**
*   **Classic (5.x):** The mature, widely-used, "Standard" version. JMS 1.1. Blocking internal architecture.
*   **Artemis:** The next-generation broker (based on HornetQ). High-performance, non-blocking (NIO), JMS 2.0 compliant.
*   **Future:** Artemis is intended to eventually replace Classic as the main ActiveMQ version.

### Question 54: Explain the concept of consumer priority in ActiveMQ.

**Answer:**
You can assign a priority (0-127) to consumers.
*   **Behavior:** ActiveMQ will dispatch messages to the consumer with the highest priority first. Only if that consumer is busy (prefetch full) or down will it send to lower-priority consumers.
*   **Config:** `destination.consumer.priority=10`.

### Question 55: What is a "Slow Consumer" handling strategy in ActiveMQ?

**Answer:**
A slow consumer can fill up the broker's memory, blocking fast producers (Producer Flow Control).
*   **Strategies:**
    *   **Pending Message Limit strategy:** Keep only the last X messages for that consumer.
    *   **Abort Connection:** Disconnect the consumer if it's too slow.
    *   **Prefetch:** Lower the prefetch limit.

### Question 56: Can ActiveMQ be embedded in a Java application?

**Answer:**
Yes. Since ActiveMQ is pure Java, you can instantiate a `BrokerService` object inside your code (e.g., Spring Boot `@Bean`) rather than running a standalone server process.
*   **Protocol:** Often used with the `vm://` transport (in-memory communication, zero network overhead).

### Question 57: What is the transport connector in ActiveMQ?

**Answer:**
A transport connector defines the endpoint that the broker exposes to accept connections from clients.
*   **Configuration:** Defined in `activemq.xml`.
*   **Example:** `<transportConnector name="openwire" uri="tcp://0.0.0.0:61616"/>` means listen on port 61616 for TCP OpenWire traffic.

### Question 58: Compare ActiveMQ with RabbitMQ.

**Answer:**
*   **ActiveMQ:**
    *   Native Java/JMS support (great for Java heavy shops).
    *   Supports "Enterprise Integration Patterns" (Camel).
    *   Slightly lower throughput than RabbitMQ in some scenarios.
*   **RabbitMQ:**
    *   Erlang-based (not JMS).
    *   Better routing logic (Exchanges).
    *   Protocol agnostic (AMQP).
    *   Generally seen as easier to scale horizontally.

### Question 59: What are the different types of subscriptions in ActiveMQ?

**Answer:**
1.  **Non-Durable Subscription:** The standard subscription. If the client disconnects, it misses any messages sent to the topic during the outage.
2.  **Durable Subscription:** The broker retains messages for the subscriber even if it is offline. When it reconnects, it receives the "missed" mail. (Requires a unique ClientID and SubscriberName).

### Question 60: How does ActiveMQ handle transactions?

**Answer:**
ActiveMQ supports:
*   **Local Transactions:** A session can be transacted. Messages sent/received are not "real" until `session.commit()` is called. If `session.rollback()` is called, sent messages are discarded and received messages are re-queued.
*   **XA Transactions:** Integration with JTA (Java Transaction API) to participate in two-phase commits (e.g., Update Database AND Send Message atomically).
